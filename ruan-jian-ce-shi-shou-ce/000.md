# 000

## 0001 DOS

盘符：C，D，E 等

<table>
  <thead>
    <tr>
      <th style="text-align:left">cd</th>
      <th style="text-align:left">change directory</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align:left">cd &#x76D8;&#x7B26;&#xFF1A;</td>
      <td style="text-align:left">&#x5207;&#x5B50;&#x76EE;&#x5F55;</td>
    </tr>
    <tr>
      <td style="text-align:left">cd ..</td>
      <td style="text-align:left">&#x5207;&#x5230;&#x4E0A;&#x7EA7;&#x76EE;&#x5F55;</td>
    </tr>
    <tr>
      <td style="text-align:left">cd/</td>
      <td style="text-align:left">&#x8FD4;&#x56DE;&#x6839;&#x76EE;&#x5F55;</td>
    </tr>
    <tr>
      <td style="text-align:left">dir</td>
      <td style="text-align:left">&#x67E5;&#x770B;&#x6709;&#x4EC0;&#x4E48;&#x5185;&#x5BB9;</td>
    </tr>
    <tr>
      <td style="text-align:left">md</td>
      <td style="text-align:left">make directory</td>
    </tr>
    <tr>
      <td style="text-align:left">echo &quot;&#x54C8;&#x54C8;&quot;&gt;a.txt</td>
      <td style="text-align:left">&#x521B;&#x5EFA;&#x540D;&#x4E3A; a &#x5185;&#x5BB9;&#x4E3A;&#x54C8;&#x54C8;&#x7684;
        txt &#x6587;&#x4EF6;</td>
    </tr>
    <tr>
      <td style="text-align:left">rd</td>
      <td style="text-align:left">
        <p>remove directory</p>
        <p>&#x5220;&#x9664;&#x7A7A;&#x76EE;&#x5F55;,&#x6587;&#x4EF6;&#x4E5F;&#x4E00;&#x8D77;&#x5220;&#x9664;&#x65F6;&#x9700;&#x8BBE;&#x7F6E;
          /s &#x53C2;&#x6570;</p>
      </td>
    </tr>
    <tr>
      <td style="text-align:left">del</td>
      <td style="text-align:left">&#x5220;&#x9664;&#x6587;&#x4EF6;&#xFF0C;&#x5220;&#x9664;&#x76EE;&#x5F55;&#x4E0B;&#x7684;&#x6240;&#x6709;&#x6587;&#x4EF6;&#xFF08;&#x4E00;&#x7EA7;&#xFF09;</td>
    </tr>
    <tr>
      <td style="text-align:left">move</td>
      <td style="text-align:left">move &#x6587;&#x4EF6;&#x540D; &#x8DEF;&#x5F84;</td>
    </tr>
    <tr>
      <td style="text-align:left">copy</td>
      <td style="text-align:left">copy &#x88AB;&#x590D;&#x5236;&#x7684;&#x6587;&#x4EF6;&#x8DEF;&#x5F84;
        &#x7C98;&#x8D34;&#x5230;&#x7684;&#x6587;&#x4EF6;&#x8DEF;&#x5F84;</td>
    </tr>
    <tr>
      <td style="text-align:left"></td>
      <td style="text-align:left">&#x590D;&#x5236;&#x5E76;&#x91CD;&#x547D;&#x540D;&#x7684;&#x5199;&#x6CD5;&#xFF1A;copy
        c:\test\aa.txt c:\test\bb.txt</td>
    </tr>
  </tbody>
</table>

## 0002 html

```text
<!DOCTYPE html>	    向浏览器声明是以 html 编写的
<html></html>	    根标签	
<head></head>	    默认有2个子标签	                    charset 用来向浏览器声明编码格式
                    title 用来显示在标签页的标题
<body></body>	    网页的内容都在 body 里面	
```

绝对路径：以盘符为起点进行查找，或者绝对 url 地址，不建议使用绝对路径

相对路径：以某个已知的文件为起点进行查找，同/上/下级路径

html 允许多个标签相互嵌套使用

#### 2.1 标签

#### **单标签** &lt;标签名 /&gt;

1. &lt;br /&gt;
2. &lt;img /&gt;

* src="地址" \# 引用的地址/嵌入
* title 鼠标悬停在上面时显示的图片名
* alt 图片加载不出时显示的文字
* width、height、backgroundcolor

#### **双标签** &lt;标签名称&gt;&lt;/标签名称&gt;

1. h1~h6

* 推荐一个网页只设一个 h1

1. &lt;p&gt;&lt;/p&gt;

* 段落

1. &lt;body&gt;&lt;/body&gt;

* 所有网页内容都写在 body 里面

1. &lt;a&gt;&lt;/a&gt;

* &lt;a href="网页地址"&gt;显示文字&lt;/a&gt; \# 用于跳转
* 引号内写 \# 代表跳回当前所在页，一般在开发时用来占位
* target="\_blank" 在新窗口打开

5.&lt;div&gt;&lt;/div&gt;

6.&lt;span&gt;&lt;/span&gt;

#### **表单** &lt;form /&gt;

用户手机用户信息的结构,

默认是空白

输入框属于表单元素 type

* action 将数据提交到哪里
* method 数据以何种形式提交到后台
* get 通过 url 传输
* post 将数据写在 http 请求的请求体当中
* 标签名称都叫 input
* 常见表单元素 单选框 &lt;input type="radio" name="aaa"&gt;
* name 属性 区分每个数据对应的表单选项
* value 文本输入框、提交按钮、重置按钮、普通按钮上显示的文本 只有 type 时可以多选
* name 相同的选项种只能选一个

#### **css 级联样式表，叠层样式表，样式表**

* 用来修饰 HTML 元素
* 使用 style 双标签关联HTML语言与css语言
*  &lt;style type="text/css"&gt;&lt;/style&gt;

#### **web标准:w3c**

*  结构样式行为三分离
* 结构 HTML搭建的架子
* 样式 使用css语言进行修饰
* 行为 通过JavaScript进行人与网页的交互

#### **选择器**

1. 调用类名的固定语法 `.类名{}`
2. 一个标签加多个类名时用空格隔开 `class="aa bb"`
3. 名称不能是纯数字/中文/包含特殊字符
4. ID 选择器用来在一堆元素中选择某一个元素
5. 调用 ID 的固定语法 `#ID名{}` ，其中 ID 是唯一的
6. 优先级 style id &gt; class &gt; element继承

`继承指子元素继承父元素的样式且一般发生在块元素上`

#### **元素**

*  块元素：每个元素独占一行，宽高属性都起作用
* 行内元素：多个元素时显示在一行并自动折行吗，宽高属性不起作用
* 行内块元素：多个元素时显示在一行但宽高属性可以起作用

`inline`

`block`

`inline-block`

`none`

#### **复合选择器**

1. 后代选择器

```text
div span{
background-color: #FA8072;
}查找 div 里的所有 span 可以不断向下嵌套
```

1. 并列选择器

```text
h4,p{
background-color: antiquewhite;
}h4，p 标签用相同的样式
```

**文字样式**

```text
div{
	line-height:1rem; /* 行高 */
	text-align: center; /* 文字的位置 center right left */
	font-size: 3rem; /* 文字的大小 */
	font-weight: bold; /* 文字加粗 100~900 900等于bold，normal正常*/
	font-family: "arial black"; /* 字体 */	color: #FAEBD7; /* 字体颜色 */	background-color: #FA8072;
	}
```

**过度样式**

```text
# 以下用来设置过度到最终样式的过程transition: all 2s linear 0.5s;
```

1.逐渐变为 :hover 的样式

2.过度的对象 过度的时间 动画形式 等待多久后执行过度

3.transition 写在 hover 里时鼠标离开立即恢复

 **:hover** 设置鼠标移上去时过渡到最后的样式样式

```text
div:hover{  
		color: #FA8072;
		background-color: #FFC99C;
		width: 250px;
		height: 250px;
		font:bold 25px/250px"agency fb";
		}
```

## 0003 软件测试行业基本介绍

####  1.1为什么需要软件测试 

1．一款软件从无到有会经历很多的开发阶段由不同的人来参与开发，所以最终产出的软件 

功能可能会存在问题。因此为了保证软件的功能是可用的，我们必须要进行测试。 

2．当前的软件件行业已经不在是功能为王了， 户不仅仅只盯着软件的功能是否满足需求， 用还会对软件是否容易上手，执行效率是否 OK .....等一系列其它体验都有了更高的要求，所以这也需要我们对软件进行大量的测试。 

1.2为什么选择软件测试 

1. 国内的软件行业对于专业的软件测试人员需求是慢慢变大。 

2. 有些人喜欢创造世界所以他们做了开发， 我们就是希望这个世界变得更加美好所以做了而测试。 

1.3、为什么不让开发自已做测试 

1．当前行业有许多的测试从业人员本身之前都是开发岗。 

2．专业度：软件测试和软件开发分别属于软件行业当中二个不同的技术方向。所以让专人 

做专事对于质量更加有保证。 

3．思维定式： 在软件的开发周期中 对于程序员来说他们大多数的时间都是在思考如何实现具体的软件功能，而不会去从用户的角度考虑如何去"奇葩"的使用这些功能。 

4．测试力度： 相对于开发来说，产器就相当于是他们的"孩子"。所以"下手"就不会那么狠。 

1.4 软件测试基本介绍 

一、软件测试定义 

通过手工或者工具对 "被测对象"进行测试操作，从而验证实际结与预期结果之间是否 

存在差异。 

二、软件测试的作用 

1．通过测试工作可以发现并修复软件当中存在的缺陷，从而提高用户对产品的使用信心。 

2．测试可以记录软件运行过程中产生的一些数据，从而为决策提供数据支持。 

3．测试可以降低同类型产品开发遇到问题的风险。 

三、测试原则： 

所谓的测试原则指的就是我们在执行测试工作时必须要遵守的一些规则。 

1．测试证明软件存在缺陷：无论执行什么样的测试操作都保能证明当前软件是有缺陷的。 

2．不能执行穷尽测试：有些功能是没有办法将所有的测试情况都逻列出来，所以任何的测 

试操作都有结束的时间。 

3．缺陷存在群集现象：对于软件功能说，核心功能占 20%，非核心是 80%。在实际工作中 我们会集中测试 20%的核心功能，所以这个部分发现缺陷的几率就会高于 80%。因此我们我们就会遇到缺陷都集中在 20% 功能模块里的现象。 

4．某些测试需要依赖特殊的环境 

5．测试应尽早介入：为了更多的发现和更好的解决软件中的缺陷，我们追求测试工作尽早 

的开展。 

6．杀虫剂现象：同样的一个测试用例不能重的执行多次，因为软件会对它产生免疫。 

7．不存在缺陷谬论：任何软件不可能是完美的。 

1.5 测试对象介绍 

对于当前的测试行业来说我们最经常测试的主体就是 软件\( 主体功能 \)，但是需要我 

们明白是一个软件也不仅仅只有功能需要测试。我们可以将软件分为三个部分组成：功能集合+使用说明书 + 配置数据。对于一款软件来说从无到有需要不同的过程，我们可以将这个过程分为不同阶段，然后每个阶段都会相应有测试对象 

1. 需求分析阶段：各种需求规格说明书。 

2. 软件架构设计：API 接口文档\( 接口测试 \) 

3. 编码实现阶段：源代码（ 白盒测试、单元测试 ） 

4. 系统功能使用：软件功能主体（ 当前行业做的最多的一种测试 ） 

1.6 测试级别 

软件的开发都会依据相应的开发模型， 测试级别指的就在这个模型当中我们人为定义则

的开发步骤。其中对于测试来说我们最常见的一种级别分类如下： 

1．单元测试\[ UT unit test \]：在软件测试中单元指的就是组成软件最小的底层代码结构， 

一般就是类、函数、组件（ 当下的软件测试行业，不会刻意要求测试人员对源代码进行测 

试 ）。 

2．集成测试\( IT system ingertaion test \):将多个单元模块组合在一起，然后验证它们之间 

沟通的"桥梁"是否能正常工作\( 接口测试 \) 

3．系统测试\( ST system test \):这是当前行业做的最多的一种测试。由测试人员充当用户 

然后对软件的功能主体进行测试。 

4．验收测试: 

\(1\) α测试 ---- 内测 

\(2\) β测试 -----公测 

\(3\) UAT\( user acceptance test \)测试---- 由客户派出对于业务非常精通的人员来使 

用该软件，从而对功能进行测试。 

\(4\) 验收测试的核心就是让用户为当前软件 "买单" 

1.7 系统测试分类 

1. 功能测试：验证当前的软件主体功能是否可用。 

2. 兼容性测试：验证当前软件在不同的环境下是否还可以使用。 

3. 安全测试：验证软件是否只是能授权用户提供功能使用。 

4. 性能测试：相对于当前软件消耗的资源 它的产出能力。 

1.8 常见的系统测试方法 

一、按测试对象进行分类 

1．白盒测试：这种测试的主体就是软件的底层代码，不会在意外在的界面是否 OK ，只要 

求底层功能实现，同时逻辑正确。 

2．黑盒测试：这种测试就是指测试软件外在主体功能是否可用。 

3．灰盒测试：介于二者之间（ 接口测试 ） 

4．上述三种方法当中的 "盒" 指的就是被测对象。 

二、按测试对象是否执行分类 

1．静态测试：指的就是测试不执行。 

2．动态测试：将软件运行在真实的使用环境中进行测试。 

三、按测试手段进行分类 

1．手工测试：由测试人员手动的对被测对象进行验证，优点就是可以灵活的改变测试操作 

及环境。 

2．自动化测试：所谓自动化主要有二种形，一种是自已写测试脚本，另外一种就是通过第 

三方的工具对被测对象进行测试。优点就是可以高效率的去执行一些人工无法实现的操作。 

1.9 软件质量 

描述当前软件是否好用，在当前的软件行业里我们所采用的一套标准是基于 ISO 组织 

制定的。需要我们记忆的就是软件质量的六大特性： 

1. 功能性：软件需要满足用户显式或者隐式的功能。 

2. 易用性：软件易于学习和上手使用。 

3. 可靠性：指的就是软件必须实现需求当中指明的具体功能。 

4. 效率性：类似于软件的性能。 

5. 可维护性：要求软件具有将某个功能修复之后继续使用的能力。 

6. 可移植性：当前软件可以从一个平台移植到另一个平台上去使用的能力。 

【 功能靠用，效率可"以" 】 

1.10 软件测试流程 

1. 需求分析 

\(1\) 当前阶段的核心目的就是梳理清楚我们需要设计的点是什么。 

\(2\) 需求的来源：需求规格说明书、API 文档、竟品分析、个人经验 

2. 设计用例： 

\(1\) 用例就是用户为了测试软件的某个功能而执行的操作过程。 

\(2\) 设计用例是有方法的（ 等价类、边界值、判定表...... ） 

3. 评审用例:对当前的用例进行添加或者删除。 

4. 配置环境 

\(1\) 环境：指的就是当前被测对象运行所需要的执行环境，做为测试人员需要具备配环 

境的能力。【 一般情况下都会使用一键安装的集成环境 】 

\(2\) 环境分类：操作系统 + 服务器软件 + 数据库 + 软件底层代码的执行环境。 

5. 执行用例 

\(1\) 一般在执行用例之前我们会做一个冒烟测试。 种测试的核心就是快速的对当前软 这

件的核心功能或者主体执行流程进行验证。如果冒烟测试阶段有问题，则可以将此 

版本回退给开发。 

\(2\) 如果冒烟测试通过那么才会开展示全面的测试。 

6. 回归测试及缺陷跟踪 

\(1\) 回归测试指的就是当我们将某个缺陷提交给开发之后，由它们进行修复，修复完成 

之后需要测试认员再次对其进行测试【回归测试】 

\(2\) 缺陷跟踪：指的就是当测试人员发现某个缺陷之后需要一直对其进行状态的跟踪。 

7. 输出测试报告 

将当前的测试过程中产生的数据进行可视化的输出。方便其它人去查看。 

8. 测试结束 

当将整个测试过程中产生的一些文档进行整理归档，方便后续版本使用。 

1.11 软件架构 

所谓的软件架构我们可以理解为是用来指导我们软件开发的一种思想。 前来说最常见 目

的二种架构模式就是 B/S C/S 

B---browser 浏览器 

C---client 客户端 

S---server 服务端 

三、二种架构的比较 

1．标准：相对于 CS 架构来说 BS 架构的二端都是在使用现成的成熟产品。所以 BS 会显示 

的标准一些。 

2．效率：相对于 BS 架构来说 CS 中的客户端可以分担一些数据的处理，因此执行效率会高 

一些。 

3．安全：B S 架构当中的数据传输都是以 HTTP 协议进行的输出，而 HTTP 协议又是明文输 

出。可以被抓包，所以相对于 CS 架构来说 BS 就显得不那么安全【相对的】 

4．升级： BS 	架构只需要在服务器端将数据进地更新， 前台只需要刷新页面就可以完成升级，而 CS 架构当中必须要将二端都进行更新。 

5．开发成本：相对于 BS 架构来说 CS 当中的客户端需要自已开发，所以相对于来说成本会 

高一些。 

1.12 浏览器基本介绍 

一、浏览器是什么 

浏览器本质就是一款软件，安装在操作系统之上。一般给用户提供浏览网页的服务。目 

前来说我们会人为的将所有浏览器总结出一个所谓的五大生产厂商。【 对于浏览器来说最 

核心技术就是内核 】 

二、五大浏览器生产厂商 

1．IE\( 微软 \)-----trident 

2．Chrome \( 谷歌 \)----blink 

3．Firefox\( 火狐 \)-----gecko 

4．Safari\( 苹果 \)-----webkit 

5．Opera\( 欧朋 \)----presto【 现在已经放弃自已东西完全向 chrome 】 

1.13 常见的图片类型 

1. Jpg\(jpeg\) :这是一种可以高度保留图片色彩信息的格式。 

2. Png：该类型的图片可以实现透明。 

3. Gif：图片所占体积小，可以实现动图 

4. Psd：它是一种分层的图片。

## 0004.Linux

开启终端入口：搜索 terminal 或者按下 Ctrl+alt+T 启动

|  |  |  | 备注 |
| :--- | :--- | :--- | :--- |
| ls | 查询当前目录下有哪些内容 | 查询当前目录下有哪些内容 | 隐藏文件名称第一位是小数点 |
|  |  |  |  |
|  |  |  | 只能在 l 时使用 |
| cd | 切换目录 | 切换目录 |  |
| mkdir | 创建文件夹 | 创建文件夹 | 只能输存在的目录 |
|  |  |  | 若目录不存在可直接创建 |
|  |  |  | 连续创建多个 |
|  |  |  |  |



